<!DOCTYPE html><html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Agar.io Style Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #111;
      overflow: hidden;
      font-family: Arial, sans-serif;
      touch-action: none;
    }
    canvas {
      display: block;
      background: radial-gradient(#222, #000);
    }
    .hud {
      position: fixed;
      top: 10px;
      left: 10px;
      color: #fff;
      font-size: 14px;
      opacity: 0.85;
      z-index: 10;
    }
    .joystick {
      position: fixed;
      bottom: 40px;
      left: 40px;
      width: 120px;
      height: 120px;
      border-radius: 50%;
      background: rgba(255,255,255,0.08);
      z-index: 10;
    }
    .stick {
      position: absolute;
      left: 40px;
      top: 40px;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: rgba(255,255,255,0.4);
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <div class="hud" id="hud"></div>
  <div class="joystick" id="joy">
    <div class="stick" id="stick"></div>
  </div>  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const hud = document.getElementById('hud');

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // ===== PLAYER SETUP =====
    const playerName = prompt('Nama pemain?', 'Player') || 'Player';
    const skins = ['#4caf50', '#2196f3', '#ff5722', '#e91e63', '#ffeb3b'];
    const playerColor = skins[Math.floor(Math.random() * skins.length)];

    const player = {
      x: canvas.width / 2,
      y: canvas.height / 2,
      radius: 22,
      speed: 3,
      color: playerColor,
      name: playerName
    };

    // ===== JOYSTICK =====
    const joy = document.getElementById('joy');
    const stick = document.getElementById('stick');
    let joyActive = false;
    let joyDX = 0;
    let joyDY = 0;

    joy.addEventListener('touchstart', e => {
      joyActive = true;
    });

    joy.addEventListener('touchmove', e => {
      if (!joyActive) return;
      const rect = joy.getBoundingClientRect();
      const t = e.touches[0];
      const x = t.clientX - rect.left - 60;
      const y = t.clientY - rect.top - 60;
      const dist = Math.hypot(x, y);
      const max = 40;
      const dx = dist > max ? (x / dist) * max : x;
      const dy = dist > max ? (y / dist) * max : y;
      stick.style.transform = `translate(${dx}px, ${dy}px)`;
      joyDX = dx / max;
      joyDY = dy / max;
    });

    joy.addEventListener('touchend', () => {
      joyActive = false;
      joyDX = joyDY = 0;
      stick.style.transform = 'translate(0,0)';
    });

    // ===== FOOD =====
    const foods = [];
    function rand(min, max) { return Math.random() * (max - min) + min; }

    function spawnFood() {
      foods.push({
        x: rand(0, canvas.width),
        y: rand(0, canvas.height),
        radius: rand(3, 6),
        color: `hsl(${Math.random() * 360},80%,60%)`
      });
    }
    for (let i = 0; i < 250; i++) spawnFood();

    // ===== ENEMIES (BOT) =====
    const enemies = [];
    const enemyNames = ['Bot01','Bot02','Bot03','Bot04','Bot05'];

    function spawnEnemy() {
      enemies.push({
        x: rand(0, canvas.width),
        y: rand(0, canvas.height),
        radius: rand(15, 35),
        speed: rand(1.2, 2.2),
        color: `hsl(${Math.random() * 360},70%,50%)`,
        name: enemyNames[Math.floor(Math.random() * enemyNames.length)]
      });
    }
    for (let i = 0; i < 6; i++) spawnEnemy();

    // ===== UPDATE =====
    function update() {
      // Player movement
      player.x += joyDX * player.speed;
      player.y += joyDY * player.speed;

      // Eat food
      for (let i = foods.length - 1; i >= 0; i--) {
        const f = foods[i];
        if (Math.hypot(player.x - f.x, player.y - f.y) < player.radius) {
          player.radius += f.radius * 0.3;
          foods.splice(i, 1);
          spawnFood();
        }
      }

      // Enemy AI
      for (const e of enemies) {
        const dx = player.x - e.x;
        const dy = player.y - e.y;
        const dist = Math.hypot(dx, dy);

        if (e.radius < player.radius) {
          e.x -= (dx / dist) * e.speed;
          e.y -= (dy / dist) * e.speed;
        } else {
          e.x += (dx / dist) * e.speed;
          e.y += (dy / dist) * e.speed;
        }

        // Enemy eat food
        for (let i = foods.length - 1; i >= 0; i--) {
          const f = foods[i];
          if (Math.hypot(e.x - f.x, e.y - f.y) < e.radius) {
            e.radius += f.radius * 0.25;
            foods.splice(i, 1);
            spawnFood();
          }
        }

        // Collision player vs enemy
        if (dist < Math.abs(player.radius - e.radius)) {
          if (player.radius > e.radius) {
            player.radius += e.radius * 0.5;
            e.radius = rand(15, 25);
            e.x = rand(0, canvas.width);
            e.y = rand(0, canvas.height);
          } else {
            alert('KALAH!');
            location.reload();
          }
        }
      }

      player.speed = Math.max(1.2, 4 - player.radius * 0.02);
      hud.innerHTML = `${player.name} â€¢ Size: ${player.radius.toFixed(0)}`;
    }

    // ===== DRAW =====
    function drawCell(x, y, r, c, name) {
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fillStyle = c;
      ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.font = `${Math.max(10, r / 2)}px Arial`;
      ctx.textAlign = 'center';
      ctx.fillText(name, x, y + 4);
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      foods.forEach(f => drawCell(f.x, f.y, f.radius, f.color, ''));
      enemies.forEach(e => drawCell(e.x, e.y, e.radius, e.color, e.name));
      drawCell(player.x, player.y, player.radius, player.color, player.name);
    }

    function loop() {
      update();
      draw();
      requestAnimationFrame(loop);
    }

    loop();
      // ===== EXTRA FEATURES =====
    let masses = [];

    function ejectMass() {
      if (player.radius < 25) return;
      player.radius -= 2;
      masses.push({
        x: player.x,
        y: player.y,
        vx: joyDX * 6,
        vy: joyDY * 6,
        radius: 4
      });
    }

    function splitPlayer() {
      if (player.radius < 40) return;
      player.radius *= 0.6;
      player.x += joyDX * 30;
      player.y += joyDY * 30;
    }

    window.addEventListener('keydown', e => {
      if (e.code === 'Space') splitPlayer();
      if (e.key === 'w') ejectMass();
    });

    function updateMasses() {
      for (let i = masses.length - 1; i >= 0; i--) {
        const m = masses[i];
        m.x += m.vx;
        m.y += m.vy;
        m.vx *= 0.95;
        m.vy *= 0.95;
        if (Math.hypot(player.x - m.x, player.y - m.y) < player.radius) {
          player.radius += 1;
          masses.splice(i, 1);
        }
      }
    }

    // ===== LEADERBOARD =====
    function drawLeaderboard() {
      const all = [...enemies, player].sort((a, b) => b.radius - a.radius);
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(canvas.width - 160, 10, 150, 160);
      ctx.fillStyle = '#fff';
      ctx.font = '12px Arial';
      ctx.fillText('Leaderboard', canvas.width - 140, 30);
      all.slice(0, 5).forEach((p, i) => {
        ctx.fillText(`${i + 1}. ${p.name}`, canvas.width - 140, 55 + i * 20);
      });
    }

    // Override draw
    const oldDraw = draw;
    draw = function () {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      foods.forEach(f => drawCell(f.x, f.y, f.radius, f.color, ''));
      masses.forEach(m => drawCell(m.x, m.y, m.radius, '#ccc', ''));
      enemies.forEach(e => drawCell(e.x, e.y, e.radius, e.color, e.name));
      drawCell(player.x, player.y, player.radius, player.color, player.name);
      drawLeaderboard();
    }

    // Override update
    const oldUpdate = update;
    update = function () {
      oldUpdate();
      updateMasses();
    }
  </script></body>
</html>
